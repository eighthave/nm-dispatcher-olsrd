#!/usr/bin/python
#

# TODO
# read in profiles and add them to NetworkManager
# check whether ActiveConnection has a mesh profile before starting olsrd
# implement using olsrd.conf as part of profile, i.e commotionwireless.net.conf
# create GNOME panel applet to show mesh status
# any use for the env vars sent with 'up'?

import glob
import os
import pyjavaproperties
import re
import sys
import NetworkManager
import subprocess


class MeshConnection():

    def __init__(self, interface, status):
        self.f = open('/tmp/nm-dispatcher-olsrd.log', 'ab')
        self.interface = interface
        self.olsrdconf = '/etc/olsrd/olsrd.conf'

        self.log('launching with "' + interface + '" and "' + status + '"')
        if status == 'up':
            meshconnection = self.getMeshConnection(interface)
            if meshconnection:
                self.startOlsrd(meshconnection['profile']['conf'])
        else:
            self.log('Ignoring ' + interface + ' ' + status)
        if status == 'down':
            self.stopOlsrd()


    def log(self, msg):
        self.f.write(msg + '\n')


    def getProfiles(self):
        '''get all the available mesh profiles and return as a dict'''
        profiles = dict()
        for f in glob.glob('/etc/nm-dispatcher-olsrd/*.profile'):
            p = pyjavaproperties.Properties()
            p.load(open(f))
            profile = dict()
            for k,v in p.items():
                profile[k] = v
            conf = re.sub('(.*)\.profile', r'\1.conf', f)
            if os.path.exists(conf):
                profile['conf'] = conf
            else:
                profile['conf'] = self.olsrdconf
            profiles[p['ssid']] = profile
        return profiles


    def readConnections(self):
        '''
        Get all pre-configured wifi connections from NetworkManager and return dict'''
        connections = dict()
        for c in NetworkManager.Settings.ListConnections():
            settings = c.GetSettings()
            if settings['connection']['type'] == '802-11-wireless':
                k = settings['connection']['id']
                connections[k] = settings
        return connections


    def matchProfile(self, ssid):
        ret = False
        profiles = self.getProfiles()
        for k,v in profiles.items():
            if k == ssid and v['ssid'] == ssid:
                return v


    def getMeshConnection(self, interface):
        '''
        match the active adhoc connection with the mesh profiles, and if there
        is a match, return the connection dict
        '''
        c = self.getAdhocConnection(interface)
        if c:
            profile = self.matchProfile(c['wireless']['ssid'])
            if profile:
                c['profile'] = profile
                return c


    def getAdhocConnection(self, interface):
        '''
        return data about the active adhoc connection for a given interface
        '''
        connection = None

        # first find the active connection that we are interested in
        foundit = False
        for ac in NetworkManager.NetworkManager.ActiveConnections:
            for d in ac.Devices:
                wireless = None
                ap = None
                if d.Managed and d.Interface == interface \
                        and d.DeviceType == NetworkManager.NM_DEVICE_TYPE_WIFI:
                    wireless = d.SpecificDevice()
                    if wireless.Mode == NetworkManager.NM_802_11_MODE_ADHOC:
                        ap = wireless.ActiveAccessPoint
                        foundit = True
                        break
            if foundit:
                break
            ac = None
        if ac == None:
            return None

        # then find the settings for that active connection
        settings = ac.Connection.GetSettings()
        if settings and ap \
                and settings['connection']['type'] == '802-11-wireless' \
                and ap.Ssid == settings['802-11-wireless']['ssid']:
            w = dict()
            w['mac-address'] = wireless.HwAddress
            w['bitrate'] = wireless.Bitrate
            w['ssid'] = ap.Ssid
            w['bssid'] = ap.HwAddress
            w['channel'] = (ap.Frequency - 2407) / 5
            w['maxbitrate'] = ap.MaxBitrate
            w['strength'] = ap.Strength
            self.log('Found mesh adhoc connection: ' + w['ssid'] + '/'
                     + w['bssid'] + '/' + str(w['channel']))
            connection = settings
            connection['wireless'] = w

        return connection


    def startOlsrd(self, conf):
        '''start the olsrd daemon'''
        self.log('start olsrd: ')
        cmd = ['/usr/sbin/olsrd', '-i', self.interface, '-f', conf]
        self.log(" ".join([x for x in cmd]))
        p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        out, err = p.communicate()
        if out:
            self.log('stdout: ' + out)
        if err:
            self.log('stderr: ' + err)


    def stopOlsrd(self):
        '''stop the olsrd daemon'''
        self.log('stop olsrd')
        cmd = ['/usr/bin/killall', '-v', 'olsrd']
        self.log(" ".join([x for x in cmd]))
        p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        out, err = p.communicate()
        if out:
            self.log('stdout: ' + out)
        if err:
            self.log('stderr: ' + err)



interface = sys.argv[1]
status = sys.argv[2]
m = MeshConnection(interface, status)
